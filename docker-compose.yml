version: "3.8"

services:
  land_app:
    build:
      context: ./ardhi
      dockerfile: Dockerfile
    container_name: ardhi_app
    hostname: land_app
    command: >
      sh -c "python3 manage.py wait_for_db &&
             python manage.py migrate &&
             python manage.py collectstatic --noinput --clear &&
             gunicorn ardhi.wsgi:application --bind 0.0.0.0:8000"
  #          python manage.py runserver 0.0.0.0:8000"
  # docker-compose run djangoapp hello/manage.py collectstatic --no-input
            
    volumes:
      - ./ardhi:/home/app/web
      - static_volume:/home/app/web/static
      - media_volume:/home/app/web/media
    # ports:
    #   - 8000:8000
    expose:
      - 8000
    env_file:
      - ./ardhi/.env
    environment:
      - DEBUG=${DEBUG}
      - ALLOWED_HOSTS=${ALLOWED_HOSTS}
      - PG_DB_HOST=${PG_DB_HOST}
      - POSTGRES_USER=${PG_USER}
      - POSTGRES_PASS=${PG_PASS}
      - POSTGRES_DB=${PG_NAME}
      - CELERY_BROKER=${CELERY_BROKER}
      - CELERY_BACKEND=${CELERY_BACKEND}
    restart: "on-failure"
    depends_on:
      - postgres-db
      - redis
    networks:
      # - front-end
      # - back-end
      - land_app


  postgres-db:
    restart: "on-failure"
    image: kartoza/postgis:12.0
    container_name: postgis_db
    hostname: postgres-db
    ports:
      - 5432:5432
    volumes:
      - postgres_data:/var/lib/postgresql
    env_file:
      - ./ardhi/.env
    environment:
      - POSTGRES_USER=${PG_USER}
      - POSTGRES_PASS=${PG_PASS}
      - POSTGRES_DB=${PG_NAME}
      - POSTGRES_MULTIPLE_EXTENSIONS=postgis,hstore,postgis_topology,postgis_raster,pgrouting,
    networks:
      # - back-end
      - land_app

  pgadmin:
    container_name: pgadmin
    image: dpage/pgadmin4
    hostname: pgadmin
    restart: unless-stopped
    env_file:
      - ./ardhi/.env
    environment:
      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_DEFAULT_EMAIL}
      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_DEFAULT_PASSWORD}
    ports:
      - ${PGADMIN_PORT}:80

    depends_on:
      - postgres-db
    networks:
      - land_app


  geoserver:
    image: kartoza/geoserver:${GS_VERSION}
    build:
      context: ./compose/geoserver
      dockerfile: Dockerfile
      args:
        args:
          IMAGE_VERSION:${IMAGE_VERSION}
          JAVA_HOME:${JAVA_HOME}
          GS_VERSION:${GS_VERSION}
          WAR_URL:${WAR_URL}
          ACTIVATE_ALL_STABLE_EXTENTIONS:${ACTIVATE_ALL_STABLE_EXTENTIONS}
          ACTIVATE_ALL_COMMUNITY_EXTENTIONS:${ACTIVATE_ALL_COMMUNITY_EXTENTIONS}
    container_name: geoserver
    hostname: geoserver
    env_file:
      - ./ardhi/.env
    volumes:
     - geoserver_data:/opt/geoserver/data_dir
     - /tmp/settings/epsg.properties:/opt/geoserver/data_dir/user_projections/epsg.properties
    ports:
     - ${GEOSERVER_PORT}:8080
    restart: on-failure
    depends_on:
      - postgres-db 
    networks:
      - land_app
    environment:
       - GEOSERVER_DATA_DIR=${GEOSERVER_DATA_DIR}
       - GEOWEBCACHE_CACHE_DIR=${GEOWEBCACHE_CACHE_DIR}
       - GEOSERVER_ADMIN_PASSWORD=${GEOSERVER_ADMIN_PASSWORD}
       - GEOSERVER_ADMIN_USER=${GEOSERVER_ADMIN_USER}
       - INITIAL_MEMORY=${INITIAL_MEMORY}
       - MAXIMUM_MEMORY=${MAXIMUM_MEMORY}
       - RECREATE_DATADIR=${RECREATE_DATADIR}
       - ACTIVATE_ALL_STABLE_EXTENTIONS:${ACTIVATE_ALL_STABLE_EXTENTIONS}
       - ACTIVATE_ALL_COMMUNITY_EXTENTIONS:${ACTIVATE_ALL_COMMUNITY_EXTENTIONS}

  redis:
    restart: unless-stopped
    container_name: redis
    image: "redis:alpine"
    ports:
      - "6379:6379"
    volumes:
      - redisdata:/data
    networks:
      - land_app
      # - back-end

  celery:
    restart: always
    container_name: celery
    build:
      context: ./ardhi
    command: celery -A ardhi worker -l info
    env_file:
      - ./ardhi/.env
    volumes:
      - ./ardhi:/home/app/web
    # environment:
    #   - DEBUG=${DEBUG}
    #   - PG_DB_HOST=${PG_DB_HOST}
    #   - POSTGRES_USER=${PG_USER}
    #   - POSTGRES_PASS=${PG_PASS}
    #   - POSTGRES_DB=${PG_NAME}
    #   - ALLOWED_HOSTS=${ALLOWED_HOSTS}
    #   # - CELERY_BROKER=${CELERY_BROKER}
    #   # - CELERY_BACKEND=${CELERY_BACKEND}
    depends_on:
      - postgres-db
      - redis
      - land_app
      - nginx

  nginx:
    restart: unless-stopped
    depends_on:
      - land_app
    volumes:
      - static_volume:/home/app/web/static
      - media_volume:/home/app/web/media
    build:
      context: ./compose/nginx
      dockerfile: Dockerfile
    container_name: nginx
    ports:
      - 1337:80
      # - 443:443
    networks:
      - land_app

networks:
  land_app:
    driver: bridge

# networks:
#   front-end:
#   back-end:


  # networks:
  #   nginx_network:
  #     driver: bridge
  #   database1_network:  # <-- add the bridge
  #     driver: bridge


volumes:
  postgres_data:
  static_volume:
  media_volume:
  redisdata:
  geoserver_data:





  #   celery:
  #     restart: always
  #     build:
  #       context: .
  #       dockerfile: ./dockerfile
  #     container_name: celery
  #     entrypoint: /bin/sh
  #     command: ./docker.celery.sh
  #     volumes:
  #       - .:/usr/src/app
  #       - static_volume:/usr/src/app/static
  #       - media_volume:/usr/src/app/media
  #     env_file:
  #       - ./core/env/env.prod
  #     depends_on:
  #       - django
  #       - redis
  #   redis:
  #     restart: always
  #     image: redis:alpine
  #     container_name: redis
  #     volumes:
  #       - redisdata:/data
  #   nginx-proxy:
  #     container_name: nginx-proxy
  #     build: ./nginx
  #     restart: always
  #     ports:
  #       - 443:443
  #       - 80:80
  #     volumes:
  #       - static_volume:/usr/src/app/static
  #       - media_volume:/usr/src/app/media
  #       - certs:/etc/nginx/certs
  #       - html:/usr/share/nginx/html
  #       - vhost:/etc/nginx/vhost.d
  #       - /var/run/docker.sock:/tmp/docker.sock:ro
  #     depends_on:
  #       - django
  #   nginx-proxy-letsencrypt:
  #     image: jrcs/letsencrypt-nginx-proxy-companion
  #     env_file:
  #       - ./core/env/env.prod.proxy-companion
  #     volumes:
  #       - /var/run/docker.sock:/var/run/docker.sock:ro
  #       - certs:/etc/nginx/certs
  #       - html:/usr/share/nginx/html
  #       - vhost:/etc/nginx/vhost.d
  #     depends_on:
  #       - nginx-proxy
  # volumes:
  #   redisdata:
  #   static_volume:
  #   media_volume:
  #   certs:
  #   html:
  #   vhost:







# 
#  qgis:
#    image: kartoza/qgis-server
#    container_name: QGIS
#    hostname: qgis-server
#    volumes:
#      # Wherever you want to mount your data from
#      - ./project:/project
#    links:
#      - postgres-db:postgres-db
#    ports:
#      - "8080:80"
#    environment:
#      QGIS_PROJECT_FILE: ''
#      QGIS_DEBUG 5
#      QGIS_LOG_FILE /proc/self/fd/1
#      QGIS_SERVER_LOG_FILE /proc/self/fd/1
#      QGIS_SERVER_LOG_LEVEL 5
#      PGSERVICEFILE /project/pg_service.conf
#      QGIS_PROJECT_FILE /project/project.qgs
#      QGIS_PLUGINPATH /opt/qgis-server/plugins
#    stdin_open: true
#    tty: true
#    extra_hosts:
#      - postgis.kartoza.com:postgis.kartoza.com
#    volumes_from:
#      - bstync



  #    qgis-server:
  #      # Should use version with utf-8 locale support:
  #      image: qgis-server:latest
  #      volumes:
  #        - REPLACE_WITH_FULL_PATH/data:/data:ro
  #      environment:
  #        - LANG=en_EN.UTF-8
  #        - QGIS_PROJECT_FILE=/data/osm.qgs
  #        - QGIS_SERVER_LOG_LEVEL=0  # INFO (log all requests)
  #        - DEBUG=1                  # display env before spawning QGIS Server
  #        - VIRTUAL_HOST=qgis-server.com
  #        - LETSENCRYPT_HOST=qgis-server.com
  #        - LETSENCRYPT_EMAIL=youremail@gmail.com

